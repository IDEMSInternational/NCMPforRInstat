#' @title Calculate Climatological Monthly and Annual Indices
#' 
#' @description
#' This function calculates various climatological monthly and annual climate indices
#' using daily climate data.The indices include mean temperature, temperature anomalies, precipitation totals,
#' precipitation anomalies, standardized precipitation index (SPI), and various temperature percentiles.
#' 
#' @param df A data.frame containing daily climate data.
#' @param station The name of the station column in the data frame.
#' @param date The name of the date column in the data frame.
#' @param precip The name of the precipitation/rain column in the data frame.
#' @param tmax The name of the maximum temperature column in the data frame.
#' @param tmin The name of the minimum temperature column in the data frame.
#' @param qct Quality Control level for temperature data (0, 1, or 2).
#' @param qcpr Quality Control level for precipitation data (0, 1, or 2).
#' @param nybr The start year for the climatological period.
#' @param nyer The end year for the climatological period.
#' @param station_df A data.frame containing station metadata.
#' @param name The name of the station column in station data frame (to link with df).
#' @param lat The name of the latitude column in station data frame.
#' @param lon The name of the longitude column in station data frame.
#'
#' @return A data frame containing calculated monthly and annual climate indices.
#' 
#' @export
#'
#' @details
#' This function is adapted from the \href{https://github.com/ET-NCMP/NCMP}{ET-NCMP/NCMP} and modified for use in R-Instat.
#' The modifications include changes to data input and output processes while preserving the core calculation methods.
#' The function calculates various climate indices for each station in the given data frame.It requires daily climate data,
#' including maximum temperature (tmax), minimum temperature (tmin),and precipitation (precip). The function calculates monthly 
#' and annual indices, including mean temperature,temperature anomalies, precipitation totals, precipitation anomalies, 
#' standardized precipitation index (SPI),and various temperature percentiles. The climatology is defined by 
#' the \code{nybr} (start year) and \code{nyer} (end year) parameters.
#' 
#' @examples
#' # Example usage:
#' # indices_result <- p2_indices(df = climate_data, station = "StationID", date = "Date",
<<<<<<< HEAD
#' # precip = "Precipitation", tmax = "MaxTemperature",
#' # tmin = "MinTemperature", qcpr = 2, nybr = 1981, nyer = 2010,
#' # station_df = station_metadata, name = "StationName",
#' # lat = "Latitude", lon = "Longitude")
=======
#' #                           precip = "Precipitation", tmax = "MaxTemperature",
#' #                            tmin = "MinTemperature", qcpr = 2, nybr = 1981, nyer = 2010,
#' #                            station_df = station_metadata, name = "StationName",
#' #                            lat = "Latitude", lon = "Longitude")
>>>>>>> ad8e52af2ed97487b0aba58e9c1653ac4c517da7
#' 
#' @references reference
#' For the original source code and more information, please refer to: \href{https://github.com/ET-NCMP/NCMP}{ET-NCMP/NCMP}
#' 
p2_indices <- function(df, station, date, precip, tmax, tmin, qct = 0, qcpr = 0, nybr = 1981, nyer = 2010,
                       station_df, name, lat, lon) {
  
  ###################################################################################
  # Set variables with key thresholds for climatological reference period           #
  # and for the number of missing days within a month and a year                    #
  # These are values which have been determined by the ET-NCMP for the purposes of  #
  # generating NCMPs and may differ from other standards or guidulines              #
  # ***** DO NOT CHANGE THE VALUE OF THESE VARIABLES *****                          #
  ###################################################################################
  
  stnhi <- 200L  # maximum number of stations
  yrlo <- 1900L  # earliest possible year for reference period
  yrhi <- as.POSIXlt(Sys.time())$year + 1899L # latest possible year == current - 1
  yclo <- 1981L  # recommended start year for climatological period (WMO-1201, 2017)
  ychi <- 2010L  # recommended end year for climatological period (WMO-1201, 2017)
  cthresh <- 20L # number of years required for calculating a valid climatology
  missm <- 10L   # No. of missing days allowable for valid month (WMO-1201, 2017)
  missa <- 36L   # No. of missing days allowable for valid year (no standard)
  
  stopifnot(qct %in% 0:2)
  stopifnot(qcpr %in% 0:2)
  
  yr1 <- yrlo
  yr2 <- yrhi - cthresh + 1L
  if (nybr < yr1 || nybr > yr2) stop("Start year for climatological period must be between ", yr1, " and ", yr2, ".")
  yr1 <- nybr + cthresh - 1L
  yr2 <- yrhi
  if (nyer < yr1 || nyer > yr2) stop("End year for climatological period must be between ", yr1, " and ", yr2, ".")
  
  files <- data.frame(FileName = station_df[[name]],
                      Lat = station_df[[lat]],
                      Long = station_df[[lon]], stringsAsFactors = FALSE)
  
  stations_data <- as.character(unique(df[[station]]))
  stations_metadata <- as.character(unique(station_df[[station]]))
  if (!all(stations_data %in% stations_metadata)) stop("Station information not available for all stations that appear in data.")
  stations <- stations_data
  nstn <- length(stations)
  
  ###################################################################################
  # Set up miscellaneous variables                                                  #
  ###################################################################################
  
  max.miss <- c(monthly = missm, annual = missa)  # for climdexInput.raw
  
  month_name_english <- c("January", "February", "March", "April", "May", "June", "July", 
                          "August", "September", "October", "November", "December")
  
  # Output column names (now standard across CSV files)
  cnames <- c("Year", month_name_english, "Annual")
  
  # Fixed days per month
  Days <- c(31L, 28L, 31L, 30L, 31L, 30L, 31L, 31L, 30L, 31L, 30L, 31L)
  
  namex <- c("TM", "TMA", 
             "PrA", "PrAn", "Pr", "PrR", 
             "SPI", 
             "TX90p", "TN90p", 
             "TX10p", "TN10p", 
             "RXday1_date", "RXday1", "TXx_date", "TXx", "TNx_date", "TNx",
             "TXn_date", "TXn", "TNn_date", "TNn")
  labx <- c("Monthly Mean Temp", "Monthly Mean Temp Anom",
            "Monthly Total Prec Anom", "Monthly Total Prec Anom Norm", "Monthly Total Prec", "Monthly Total Prec Ratio",
            "Standard Prec Index",
            "Warm Days", "Warm Nights",
            "Cold Days", "Cold Nights",
            "Extreme Prec Date", "Extreme Prec", "Extreme Warm Day Date", "Extreme Warm Day", "Extreme Warm Night Date", "Extreme Warm Night",
            "Extreme Cold Day Date", "Extreme Cold Day", "Extreme Cold Night Date", "Extreme Cold Night")
  
  ###################################################################################
  # Begins loop for reading data files and doing calculations                       #
  ###################################################################################
  
  by_month_stations <- vector(mode = "list", length = nstn)
  names(by_month_stations) <- stations
  for (i in 1:nstn) {
    
    data <- df %>% dplyr::filter(.data[[station]] == stations[i])
    data <- data.table::data.table(Year = lubridate::year(data[[date]]),
                                   Mo = lubridate::month(data[[date]]),
                                   Day = lubridate::mday(data[[date]]),
                                   Prec = data[[precip]],
                                   Tx = data[[tmax]],
                                   Tn = data[[tmin]]
    )
    
    ###################################################################################
    #    Find mean temperature and monthly values                                     #
    ###################################################################################
    
    Tm <- (data[,"Tx"] + data[,"Tn"])/2.0
    data$Tm <- Tm
    
    # Copy for creating monthly values
    data1 <- data
    data1$Prec[data1$Prec < 1] <- 0  # replace prec less than 1 with 0
    Mo <- data1$Mo
    Prec <- data1$Prec
    Year <- data1$Year
    
    # Calculate monthly values where missing days are below the threshold
    # Would be desirable to allow for leap years, but this would be rather harder
    # as need to account for partial months and years 
    
    Month <- data1[,list(
      Pr = ifelse(Days[Mo] - sum(!is.na(Prec)) > missm, NA_real_, sum(Prec, na.rm=TRUE)),
      Tm = ifelse(Days[Mo] - sum(!is.na(Tm)) > missm, NA_real_, mean(Tm, na.rm=TRUE))), by = list(Year, Mo)]
    
    # Calculate annual value where missing days are below the threshold
    Year <- data1[,list(
      Pr.Y = ifelse(365L - sum(!is.na(Prec)) > missa, NA_real_, sum(Prec, na.rm = TRUE)),
      Tm.Y = ifelse(365L - sum(!is.na(Tm)) > missa, NA_real_, mean(Tm, na.rm = TRUE))), by = Year]
    
    # Shape monthly values into table by year
    # This now explicitly uses data.table::dcast >= 1.9.6
    
    Month.Y <- data.table::dcast(Month, Year~Mo, value.var = c("Pr", "Tm"), sep = ".", fill = NA)
    Month.Y <- data.table::merge.data.table(Month.Y, Year, by = "Year")  # No need to sort (in all locales?)
    Month.Y <- round(Month.Y, 2)  # round table to 2 digits
    
    # Having dcast multiple variables, split them back up for further processing
    # This seems to be the only way to evaluate the correct column names
    
    colp <- c("Year", paste("Pr", c(1:12,"Y"), sep = "."))
    Prec <- Month.Y[, colp, with = FALSE]
    colnames(Prec) <- cnames
    
    colt <- c("Year", paste("Tm", c(1:12, "Y"), sep = "."))
    Temp <- Month.Y[, colt, with = FALSE]
    colnames(Temp) <- cnames
    
    by_month <- tidyr::pivot_longer(Prec, cols = 2:14, names_to = "month", names_ptypes = list(month = factor(levels = cnames[2:14])),
                                    values_to = namex[5])
    Temp_stack <- tidyr::pivot_longer(Temp, cols = 2:14, names_to = "month", names_ptypes = list(month = factor(levels = cnames[2:14])),
                                      values_to = namex[1])
    by_month[[namex[1]]] <- Temp_stack[[namex[1]]]
    
    ###################################################################################
    #    Calculate climatology for mean temp and avg prec                             #
    # Save swapping by using R internal representation of missing values == NA(_real_)#
    # Require 'cthresh' years (recommend == 20) for non-missing value                 #
    ###################################################################################
    
    ref <- (Prec$Year >= nybr & Prec$Year <= nyer)
    Clim.T <- ifelse(colSums(!is.na(Temp[ref,])) >= cthresh,colMeans(Temp[ref,] , na.rm=TRUE) , NA_real_)
    Clim.P <- ifelse(colSums(!is.na(Prec[ref,])) >= cthresh,colMeans(Prec[ref,], na.rm=TRUE) , NA_real_)
    
    ###################################################################################
    #    Fill zeroes in precipitation climatology                                     #
    # Use full period to calculate an extended precipitation climatology              #
    # and fill zeroes in the shorter standard precipitation climatology if needed.    #
    # if it is still zero, set it to 0.1 mm                                           #
    ###################################################################################
    ref_ext <- (Prec$Year >= 0 & Prec$Year <= 9999)
    Clim_ext.P <- ifelse(colSums(!is.na(Prec[ref_ext,])) >= cthresh, colMeans(Prec[ref_ext,], na.rm = TRUE), NA_real_)
    for (mn in 2:13) {
      if (!is.na(Clim.P[mn])) {
        if (Clim.P[mn] == 0) { 
          cat("Replacing zero in climatology period with average for full series", fill = TRUE)
          Clim.P[mn] <- Clim_ext.P[mn]
          if (Clim.P[mn] == 0) { Clim.P[mn] <- 0.1 }
        }
      }
    }
    
    ###################################################################################
    #    Calculate the temperature anomaly for mean temp                              #
    # Subtract Climatology from each row                                              #
    # Note that NA, column names etc are taken care of, but leave Year unchanged      #
    ###################################################################################
    # Utilises R vector recycling, but need to transpose Temp to do this
    
    Clim.T[1] <- 0
    Temp.Anom <- round(t(t(Temp) - Clim.T), 2)
    Temp.Anom_stack <- tidyr::pivot_longer(as.data.frame(Temp.Anom), cols = 2:14, names_to = "month", 
                                           names_ptypes = list(month = factor(levels = cnames[2:14])),
                                           values_to = namex[2])
    by_month[[namex[2]]] <- Temp.Anom_stack[[namex[2]]]
    
    ###################################################################################
    #    Calculate the precipitation ratios and anomalies                             #
    # This is a bit more difficult to deal with the Year column                       #
    ###################################################################################
    
    Clim.P[1] <- 100
    Prec.Rat <- round(t(t(Prec)/Clim.P*100),1)
    Clim.P[1] <- 0
    Prec.Anom <- round(t(t(Prec) - Clim.P),1)
    Prec.Nor.Anom <- round(t((t(Prec)-Clim.P)/Clim.P*100),1)
    Prec.Nor.Anom[,"Year"] <- Prec.Anom[,"Year"]
    
    Prec.Rat_stack <- tidyr::pivot_longer(as.data.frame(Prec.Rat), cols = 2:14, names_to = "month",
                                          names_ptypes = list(month = factor(levels = cnames[2:14])),
                                          values_to = namex[6])
    by_month[[namex[6]]] <- Prec.Rat_stack[[namex[6]]]
    Prec.Anom_stack <- tidyr::pivot_longer(as.data.frame(Prec.Anom), cols = 2:14, names_to = "month",
                                           names_ptypes = list(month = factor(levels = cnames[2:14])),
                                           values_to = namex[3])
    by_month[[namex[3]]] <- Prec.Anom_stack[[namex[3]]]
    Prec.Nor.Anom_stack <- tidyr::pivot_longer(as.data.frame(Prec.Nor.Anom), cols = 2:14, names_to = "month",
                                               names_ptypes = list(month = factor(levels = cnames[2:14])),
                                               values_to = namex[4])
    by_month[[namex[4]]] <- Prec.Nor.Anom_stack[[namex[4]]]
    
    ###################################################################################
    #    Calculate the standardized precpitation index                                #
    ###################################################################################
    # Currently replacing zeroes with NA to get the correct log values
    # But this results in zero monthly rainfall with missing SPI - probably not right
    # The PZero variable suggests that this can be better handled
    # Also can investigate definitions suitable for arid climates
    
    nyrs <- nrow(Prec)            # get dim of Prec; Prec monthly total when daily >=1
    Prec2 <- Prec[,-1, with = FALSE] # Exclude Year column
    PZero <- colSums(Prec2 == 0, na.rm = TRUE)/nyrs # fraction of 0 values, by counting
    Prec2[Prec2 == 0] <- NA
    
    A <- log(colMeans(Prec2, na.rm = TRUE)) - colMeans(log(Prec2), na.rm = TRUE)
    Alpha <- ((1+sqrt(1+4*A/3))/(4*A))          # Find alpha parameter for each month
    Beta <- colMeans(Prec2, na.rm = TRUE)/Alpha    # Find  beta parameter for each month
    
    Gamma.Prob <- apply(Prec2, 1, stats::pgamma, shape = Alpha, scale = Beta)   # Implicit over rows
    Prob <- PZero+(1-PZero)*Gamma.Prob         # normalize with prob of zero; bet 0-1
    SPI <- round(stats::qnorm(Prob, mean = 0, sd = 1), 1) # input prob into normal quantile func bet -3-3
    SPI <- cbind(Prec[,list(Year)], t(SPI))
    
    SPI_stack <- tidyr::pivot_longer(SPI, cols = 2:14, names_to = "month",
                                     names_ptypes = list(month = factor(levels = cnames[2:14])),
                                     values_to = namex[7])
    by_month[[namex[7]]] <- SPI_stack[[namex[7]]]
    
    ###################################################################################
    #    Calculate the daily 10th and 90th % of Tx & Tn                               #
    # Due to a probable error in climdex.pcic:::percent.days.op.threshold when have   #
    # less than the base period, bypass the wrappers and use a modified,              #
    # and hopefully correct, calculation of monthly and annual percentages            #
    ###################################################################################
    
    dd <- data[, paste(Year, Mo, Day, sep = "-")]    # YYYY-MM-DD as string from data.table
    D1 <- PCICt::as.PCICt(dd, cal = "gregorian")         # String represented as Gregorian date
    D <- climdex.pcic::climdexInput.raw(tmax = data[,Tx], tmin = data[,Tn], prec = data[,Prec],
                                        tmax.dates = D1, tmin.dates = D1,prec.dates = D1,
                                        base.range = c(nybr, nyer), max.missing.days = max.miss)
    dd <- strsplit(levels(D@date.factors$monthly), "-")    # have padded partial years
    Year <- as.integer(sapply(dd,"[[",1))
    Mo <- as.integer(sapply(dd,"[[",2))
    
    # This setup allows for looping over the percentile variables
    # 1 = Warm days, 2 = Warm nights, 3 = Cold days, 4 = Cold nights
    
    for (ix in 8:11) {
      ne <- namex[ix]
      
      # Calculate monthly and annual percentages for this diagnostic - round to 2dp
      NCMP45.M <- round(percent.days.op.threshold.mod(D, "monthly", ne), 2)
      NCMP45.Y <- round(percent.days.op.threshold.mod(D, "annual", ne), 2)
      
      # Combine monthly and annual values by casting monthly table into years
      
      NCMP45 <- data.table::data.table(Year, Mo, NCMP45.M)
      NCMP45 <- data.table::dcast(NCMP45, Year~Mo, value.var = "NCMP45.M")
      NCMP45 <- cbind(NCMP45, NCMP45.Y)
      
      # Write to file with standardised column names
      
      colnames(NCMP45) <- cnames
      NCMP45_stack <- tidyr::pivot_longer(NCMP45, cols = 2:14, names_to = "month",
                                          names_ptypes = list(month = factor(levels = cnames[2:14])),
                                          values_to = namex[ix])
      by_month[[namex[ix]]] <- NCMP45_stack[[namex[ix]]]
    }
    
    ###################################################################################
    #    Calculate the Highest and Lowest Values Tx, Tn and RX1                       #
    # This is known to cause problems with extended periods of missing data,          #
    # and currently prevents the use of precipitation-only stations                   #
    # This is probably caused by which.max/min() returning integer(0)                 #
    # when no data is valid for that month/year                                       #
    # This also defines monthly extreme if *any* value is present, as opposed to      #
    # applying missing value limits for monthly mean/totals                           #
    # One alternative is to use climdex.pcic, although extracting day of month        #
    # then becomes more difficult                                                     #
    # Another alternative is calculate these alongside the basic monthly indices      #
    # in the data.table object - although that might get a bit messy                  #
    ###################################################################################
    
    # Retain only the Day and value in each row (or add dateMD/DY if used)
    # If extreme monthly precipitation is zero, sensible to set day index to missing
    
    RX1X <- data[,.SD[which.max(Prec),list(Day,Prec)], by = list(Year,Mo)]
    RX1X[,Day := ifelse(RX1X[,Prec] == 0, NA, RX1X[,Day])]
    TxXX <- data[,.SD[which.max(Tx),list(Day,Tx)], by = list(Year,Mo)]
    TnXX <- data[,.SD[which.max(Tn),list(Day,Tn)], by = list(Year,Mo)]
    TxNN <- data[,.SD[which.min(Tx),list(Day,Tx)], by = list(Year,Mo)]
    TnNN <- data[,.SD[which.min(Tn),list(Day,Tn)], by = list(Year,Mo)]
    
    # If no data, set all index values to missing - use a dummy table for all cases
    # This does not appear to be working as intended, given the observed issues
    
    yrs <- range(data[,Year])
    dummy <- data.table::data.table(Year = c(yrs[1]:yrs[2], "xxxx"), t(rep(NA, 13)))
    
    # By putting the 5 records into a list, it is possible to loop over them
    # However, must distinguish between max and min records, and make sure that the
    # order lines up with the indices as defined by "ele"
    
    listVX <- list(RX1X, TxXX, TnXX, TxNN, TnNN)
    rn <- c("HiPr", "HiTx", "HiTn", "LoTx", "LoTn")       # row names for end of table
    colV <- c("Year", paste("Var", 1:12, sep="_"), "Var") # Std column names for variable
    colD <- c("Year", paste("Day", 1:12, sep="_")) # Standard column names for day index
    
    for (ne in 1:5) {
      ix <- ne * 2L + 10L          # offset into "namex" for file names
      VarX <- listVX[[ne]]       # copy of records table
      colnames(VarX)[4] <- "Var" # standard data column name - works in data.table
      if (nrow(VarX) == 0L) {
        dummy[nrow(dummy),1] <- rn[ne]
        Var <- dummy
        Var.D <- dummy
      } else {
        
        # Extract the extreme values for each month and year
        # This should give the actual years for which extreme indices were calculated
        # Also extract month and value for absolute extreme (ie over all days in data)
        
        if (ne <= 3L) {
          MVarX <- VarX[,.SD[which.max(Var)],by=list(Mo)]
          YVarX <- VarX[,.SD[which.max(Var)],by=list(Year)]
          Var.MY <- as.numeric(VarX[,.SD[which.max(Var),list(Mo,Var)]])
        } else {
          MVarX <- VarX[,.SD[which.min(Var)],by=list(Mo)]
          YVarX <- VarX[,.SD[which.min(Var)],by=list(Year)]
          Var.MY <- as.numeric(VarX[,.SD[which.min(Var),list(Mo,Var)]])
        }
        
        # Combine monthly and annual records - do need to worry about the table order
        
        MVarX <- MVarX[order(Mo)]
        VarX.D <- data.table::dcast(VarX, Year~Mo, value.var = c("Day", "Var"),fill = NA)
        VarX.all <- data.table::merge.data.table(VarX.D, YVarX, by = "Year")
        
        # Separate extreme value and day index
        # Day index "Annual" value is the month of extreme value
        
        Var <- VarX.all[,colV, with = FALSE]
        Var.D <- VarX.all[,colD, with = FALSE]
        # DP Replaced month.abb with 1:12 so that annual value can be stacked with month values.
        # DP May need to convert back to month.abb in other scripts that use this.
        Var.D$Annual <- (1:12)[as.matrix(VarX.all[,list(Mo)])]
        
        # Add monthly row to output: year of extreme to index, value to data
        # This is somewhat murky - and putting month/extreme of extreme in "annual"
        
        # DP Removed to avoid merging issues in long format. Overall extremes can be calculated if necessary.
        # xx <- c(rn[ne], as.list(MVarX[,Var]), Var.MY[2])
        # Var <- rbind(Var, xx)
        # xx <- c(rn[ne], as.list(MVarX[,Year]), month.abb[Var.MY[1]])
        # Var.D <- rbind(Var.D, xx)
      }
      
      # Write extreme and day index to file
      colnames(Var) <- cnames
      colnames(Var.D) <- cnames
      Var_stack <- tidyr::pivot_longer(Var, cols = 2:14, names_to = "month",
                                       names_ptypes = list(month = factor(levels = cnames[2:14])),
                                       values_to = namex[ix+1L])
      # DP Sometimes output skips missing years so need to merge instead of adding column.
      if (nrow(Var_stack) != nrow(by_month)) {
        by_month <- dplyr::left_join(by_month, Var_stack, by = c("Year", "month"))
      } else by_month[[namex[ix+1L]]] <- Var_stack[[namex[ix+1L]]]
      
      Var.D_stack <- tidyr::pivot_longer(Var.D, cols = 2:14, names_to = "month",
                                         names_ptypes = list(month = factor(levels = cnames[2:14])),
                                         values_to = namex[ix])
      if (nrow(Var.D_stack) != nrow(by_month)) {
        by_month <- dplyr::left_join(by_month, Var.D_stack, by = c("Year", "month"))
      } else by_month[[namex[ix]]] <- Var.D_stack[[namex[ix]]]
    }
    by_month_stations[[stations[i]]] <- by_month
  }
  by_month <- dplyr::bind_rows(by_month_stations, .id = station)
  for (i in seq_along(namex)) {
    attr(by_month[[namex[i]]], "label") <- labx[i]
  }
  
  # Order columns as in NCMP 1-6 order specified in user manual.
  by_month <- dplyr::select(by_month, c(station, Year, month,
                                        # NCMP1
                                        TM, TMA, 
                                        # NCMP2
                                        Pr, PrA, PrAn, PrR,
                                        # NCMP3
                                        SPI,
                                        # NCMP4
                                        TX90p, TN90p,
                                        # NCMP5
                                        TX10p, TN10p,
                                        # NCMP6
                                        TXn, TXn_date, TNn, TNn_date, RXday1, RXday1_date, TXx, TXx_date, TNx, TNx_date))
  
  ###################################################################################
  # Ends loop for stations                                                          #
  ###################################################################################
  
  dy <- date()
  attr(by_month, "dy") <- dy
  attr(by_month, "nstn") <- nstn
  attr(by_month, "nybr") <- nybr
  attr(by_month, "nyer") <- nyer
  attr(by_month, "qct") <- qct
  attr(by_month, "qcpr") <- qcpr
  
  return(by_month)
}
